Tips for Creating a Good Package
GopherConIndia 2015
20 Feb 2015

Keiji Yoshida
Software engineer, Recruit Communications Co., Ltd.
yoshida_keiji@r.recruit.co.jp
http://yoss.si/
@_yosssi

* Self Introduction

* About me

- Keiji Yoshida
- Software engineer at [[http://www.rco.recruit.co.jp/][Recruit Communications Co., Ltd.]] in Tokyo
- Using Go only for my private work

.image 0220-good-package/keiji_yoshida.jpg

* Experience of Go

- Started using Go in the beginning of 2014
- [[https://github.com/martini-contrib][Became a contributor]] to [[http://martini.codegangsta.io/][Martini]] which is a WAF for Go in April 2014
- [[http://slides.yoss.si/gocon/martini.html#/][Gave a presentation about Martini]] at [[http://connpass.com/event/6370/][Go Conference 2014 spring]] in Tokyo in May 2014
- Created some packages for building a web application in Go
.link https://github.com/yosssi/ace Ace - HTML template engine for Go
.link https://github.com/yosssi/gcss GCSS - Pure Go CSS Preprocessor

* Goal

* Share my knowledge of creating a Go package successfully

I have learned some good tips to create a Go package by having created many Go packages and having made a lot of mistakes.

This presentation is for Beginners of Go who want to create their own Go package.

* Follow the standard Go coding style

* Standard Go coding style

We should follow the standard Go coding style written in the articles below:

- [[http://golang.org/doc/effective_go.html][Effective Go - The Go Programming Language]]
- [[https://code.google.com/p/go-wiki/wiki/CodeReviewComments][CodeReviewComments - go-wiki]]

There are a lot of rules we have to follow such as:

- Every exported (capitalized) name in a program should have a doc comment
- The convention in Go is to use _MixedCaps_ or _mixedCaps_ rather than underscores to write multiword names
- Error strings should not be capitalized (unless beginning with proper nouns or acronyms) or end with punctuation, since they are usually printed following other context

*It*is*difficult*for*us*to*memorize*all*coding*rules*and*follow*them*during*coding.*

* Use Golint

[[https://github.com/golang/lint][Golint]] is a linter for Go source code.

This tool checks Go source code if the source code is following the standard Go coding style or not.

.image 0220-good-package/golint.png

* Use goimports instead of gofmt

[[http://godoc.org/code.google.com/p/go.tools/cmd/goimports][goimports]] acts the same as gofmt but in addition to code formatting, it also updates Go import lines, adds missing ones and removes unreferenced ones.

goimports also organize import lines in groups with blank lines between them. The standard library packages are in the first group.

  package main

  import (
      "fmt"
      "hash/adler32"
      "os"

      "appengine/user"
      "appengine/foo"

      "code.google.com/p/x/y"
      "github.com/foo/bar"
  )

* Make our Go packages extensible

* Export identifiers only which are needed to be so

We should not export all identifiers because exported identifiers are hard to be modified.

.code 0220-good-package/export_identifiers_ng.go /START OMIT/,/END OMIT/

Only identifiers which are needed to be exported should be exported.

.code 0220-good-package/export_identifiers_ok.go /START OMIT/,/END OMIT/

* Use Options struct as a parameter 1/4

Suppose we defined a `Dog` struct and its construct function as following:

.code 0220-good-package/options_ng1.go /START OMIT/,/END OMIT/

* Use Options struct as a parameter 2/4

If we need to add an `age` field to the `Dog` struct, we have to create a new function:

.code 0220-good-package/options_ng2.go /START OMIT/,/END OMIT/

We can not change the `NewDog` function's signature because it has beed exported.

* Use Options struct as a parameter 3/4

After the repetition of this kind of modification, a nightmare comes:

.code 0220-good-package/options_ng3.go /START OMIT/,/END OMIT/

* Use Options struct as a parameter 4/4

We can avoid adding a new function when a new field is added by using Options struct.

.code 0220-good-package/options_ok.go /START OMIT/,/END OMIT/

* Divide a large struct into small ones 1/7

When I started to creating an HTML template engine, I created a single struct which represents all of the template file's elements.

.image 0220-good-package/element_struct.png

* Divide a large struct into small ones 2/7

The `element` struct became very large because it contains all element types' processing and it lost its maintainability.

.code 0220-good-package/element_struct.go /START OMIT/,/END OMIT/

* Divide a large struct into small ones 3/7

I divided the `element` struct into small ones and created an `element` interface.

.image 0220-good-package/element_interface.png

* Divide a large struct into small ones 4/7

I could divide the single large processing into small processing and that made my package more maintainable.

.code 0220-good-package/element_interface.go /START OMIT/,/END OMIT/

* Divide a large struct into small ones 5/7

By the way, each element has its child elements just like each HTML tag does.

.code 0220-good-package/element_duplicate.go /START OMIT/,/END OMIT/

* Divide a large struct into small ones 6/7

I created a `elementBase` struct which had fields and methods common among elements.

I embed the `elementBase` struct into the structs which implemented the `element` interface.

.image 0220-good-package/element_embed.png

* Divide a large struct into small ones 7/7

By having embedded the `elementBase` struct into the structs which implemented the `element` interface, I could get rid of the duplication of fields and methods.

.code 0220-good-package/element_embed.go /START OMIT/,/END OMIT/

* Give users freedom of using our package

* Give users an option to call our APIs sequentially or concurrently

When I released my CSS preprossing package like [[http://sass-lang.com/][Sass]] which compiles a simplified CSS format file into a pure CSS format file, I made the `Compile` function run always concurrently because it involved many I/O blocking processing.

.code 0220-good-package/concurrent.go /START OMIT/,/END OMIT/
